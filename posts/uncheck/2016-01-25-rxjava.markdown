---
layout: post
title: RxJava
date: 2016-01-25T10:14:11+08:00
category: 技术
---

* TOC
{:toc}

# RxJava

## 什么是RxJava
官方定义: 

> Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.

翻译过来就是：一个用于 *使用观察者序列*   来为了*异步、事件驱动编程* 的*没有扩展JVM（即完全是java语法）*的库。

## 什么是RxAndroid
官方定义：

> Android specific bindings for RxJava.

>This module adds the minimum classes to RxJava that make writing reactive components in Android applications easy and hassle-free. More specifically, it provides a Scheduler that schedules on the main UI thread or any given Handler.

RxJava的基础上添加了Android的特性，如`main thread schedules or any given handler`。使得使用RxJava编写Android代码更容易。

## 使用RxJava有什么好处
我们为什么要使用RxJava呢

一个字，简洁。逻辑更清晰，并且随着代码逻辑的复杂化还能保持清晰。

如可以减少像这样的谜之缩进

    request.request(new OnResultListener() {
        dosomething();
        if (validateOk) {
            reqeust.request(new OnResultListener() {
               
            }) 
        }
    })


## 观察者模式

要理解RxJava。需要先理解观察者模式。所以我们先复习一下观察者模式。

用Eddie的一句话来说就是：`别联系我，我会联系你`。所以想跟Eddie约的话，只有先把号码给Eddie。等他方便的时候他会打给你。

我们来看看标准库的具体实现：

标准库的实现中，提供了一个接口和一个类。`interface Observer`、`class Observable`

简化了的代码

### Observer

    public interface Observer {
        void update(Observable o, Object arg);  //在合适时候由Observable调用
    }

### Observable

    public class Observable {
        Vector<Observer> obs;

        public void addObserver(Observer o) {
            obs.addElement(o);
        }

        public void notifyObservers(Object arg) {
            for (int i = obs.size(); i++) {
                obs.get(i).update(this, arg);
            }
        }
    }

所以就是观察者把自己交给可观察者，可观察者在状态改变的时候通知观察者。

可参看WeatherObserver Demo。

被观察者WeatherObserver

    import java.util.Observable;

    public class WeatherObservable extends Observable{
        private float temperature;
        public float getTemperature() {
            return temperature;
        }
        public void setTemperature(float temperature) {
            this.temperature = temperature;
            //我们不用管setChanged();这是框架要求我们通知变化之前要调用这个方法
            setChanged();
            //通知变化
            notifyObservers(temperature);
        }

    }

然后我们创建测试类，在测试类中新建两个观察者，观察者观察到变化之后，打印出变化。


    import java.util.Observable;
    import java.util.Observer;

    public class MainClass {    
        public static void main(String[] args) {
            //被观察者
            WeatherObservable weatherObservable = new WeatherObservable();

            //观察者1
            Observer weatherObserver1 = new Observer() {
         
                @Override
                public void update(Observable o, Object arg) {
                    System.out.println("Observer1 templature change, current templature: " + arg);
                }
            };
        
            //观察者2
            Observer weatherObserver2 = new Observer() {
         
                @Override
                public void update(Observable o, Object arg) {
                    System.out.println("Observer2 templature change, current templature: " + arg);
                }
            };
        
            //添加观察者
            weatherObservable.addObserver(weatherObserver1);
            weatherObservable.addObserver(weatherObserver2);
        
            //设置变化，会通知观察者
            weatherObservable.setTemperature(100.0f);
        }
    }

运行，结果打印：

    Observer2 templature change, current templature: 100.0
    Observer1 templature change, current templature: 100.0


## RxJava分析和使用
我们已经知道了RxJava的原理，就是一个观察者模式。

所以我们的重点就在于RxJava是如何实现并拓展观察者模式的。

现在我们来看下观察者和被观察者是怎么在RxJava中表示的。

### Observer
RxJava中改名为`Subscriber`

在RxJava中，`Observer`和`Subscriber`基本等同。当我们说`Observer`和`Subscriber`的时候，是一个意思。

在标准库中`Observer`拥有的是一个接口方法

    void update(Observable o, Object arg);  //在合适时候由Observable调用

而在`RxJava`中增加了接口方法`onComplete()`、`onError()`。

    public interface Observer<T> {
        void onNext(T t);       //相当于onUpdate(Observable o, Object org)

        void onCompleted();     //事件成功完结
        void onError(Throwable e);  //事件分发错误，因为发生错误不得不完结。和onCompleted()只能选其一发生
    }

### Observable
RxJava为了控制回调事件的流程，并没有给我们公开Observable的构造方法。也就是说，我们不能自己`new Observable`了。而只能使用框架提供的构建方式。RxJava控制了Observable的构建方式和回调策略。

RxJava的构造方法被保护起来了：

    protected Observable(OnSubscribe<T> f) {
      this.onSubscribe = f;
    }

RxJava给的创建Observable的方式在`Observable`类的静态方法里面。

* `static create(Onsubscript)`，

方法参数`OnSubscribe`是一个接口，接口中只定义了一个`call(Observer)`方法

而这个`call(Observer)`方法是做什么的呢？

这就是你写事务逻辑的地方。

比如最简单的遍历打印一个字符数组的功能，使用RxJava的写法就是

    final String[] toPrint = new String[]{"One", "Two", "Three"};
    
    //创建被观察者的地方
    observable.create(new Observable.OnSubscribe<String>() {
        @Override
        public void call(Subscriber<? super String> subscriber) {
            for (int i = 0; i < toPrint.length; i++) {
                subscriber.onNext(toPrint[i]);
            }
        }

    })

    //我们先不看下面的
    .subscribe(new Action1<String>() {
        @Override
        public void call(String s) {
            Log.i("tonghu", "printArray: " + s);
        }
    });

因为我们的功能是拆分打印字符数组。我们需要拿到的就是拿到一个一个拆分好了的单独字符串。所以我们`Observable`的功能就是拆分数组，并且每拆分好一个就通知一下他的`Observer`。嘿，我拆分好了一个，拿去吧。这就是call里面所写的代码。

现在我们有了`Observer`和`Observable`，剩下的也就是将`Observer`和`Observable`联系起来。怎么联系起来呢。记得Android标准库中`Observable`中的`addObserver(Observer o)`方法吗？在Rxjava中也有一个这样的方法`subscibe(final Observer<? super T> observer)`，只不过是改了一个名字。

好了，我们现在什么都有了。观察者，被观察者，订阅。现在来看一个例子来加深理解。

还是打印字符数组。被观察者负责拆分数组，每拆好一个就通知观察者，观察者收到一个拆分好了的字符串就打印这个字符串。

标准也是完全的实现

    void printArray() {
        final String[] toPrint = new String[]{"One", "Two", "Three"};
        //创建被观察者
        Observable<String> splitObservable = Observable.create(new Observable.OnSubscribe<String>() {
            @Override
            public void call(Subscriber<? super String> subscriber) {
                //被观察者拆分字符串,每拆分一个都告诉观察者
                for (int i = 0; i < toPrint.length; i++) {
                    subscriber.onNext(toPrint[i]);
                }
            }
        });

        //创建观察者
        Observer<String> observer = new Observer<String>() {
            @Override
            public void onCompleted() {
            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(String s) {
                Log.i("tonghu", "printArray: " + s);
            }
        };

        //注册
        splitObservable.subscribe(observer);
    }

当然我们可以代码链将代码连接起来，不需要申明变量。如果不关注`OnCompleted()`和`OnError()`的话，我们也可以不用实现这些方法。就如上面那个例子。

如果我们不关心`onComplete()`和`onError()`，则简便写法为：

    //不用传一个Obsever只需要传一个OnNext()
    public final Subscription subscribe(final Action1<? super T> onNext) {
        if (onNext == null) {
            throw new IllegalArgumentException("onNext can not be null");
        }

        return subscribe(new Subscriber<T>() {    //实际是框架给我们了一个空实现OnError和onCompleted

            @Override
            public final void onCompleted() {
                // do nothing
            }

            @Override
            public final void onError(Throwable e) {
                throw new OnErrorNotImplementedException(e);
            }

            @Override
            public final void onNext(T args) {
                onNext.call(args);
            }

        }); 
    }

如可将上面的例子改写为:
    
    observable.subscribe(new Action<String>() {
        @Override
        public void call(String t) {
            Log.i("tonghu", "printArray: " + t);
        }
    });


## RxJava对观察者模式的拓展
RxJava提供了Schedual和操作法Operator的拓展

### Schedual
上面讲的例子都没有实际用途，只是为了方便大家了解RxJava的处理流程。

上面例子中`Observable`的`call()`方法都是在调用`subscribe()`的时候被调用的，并且都是同步的。而RxJava主要用途是异步。这就引入了RxJava的另一个概念了：`Schedual`。

`Schedual`是什么呢，简单来讲就是指定执行代码的线程，包括观察者和被观察者

`Schedual`有以下模式：

* `immediate`: 直接在当前线程运行，默认。

* `newThread`: 开启新线程

* `io`: io操作（读写文件、数据库、网络交互等），类似`newThread`，但是`io`构建了一个无数量上限（未验证）的线程池，可以复用线程。但是不要把计算工作放在`io`模式中，
这样可以避免创建不必要的线程。而RxJava对计算工作单独提供了`Schedual`模式。

* `computation`: 计算线程，这个计算值得是CPU密集型计算（我们总是可以在Android官方文档上看到，不要讲CPU密集型操作和耗时操作放在主线程中执行），例如图形的计算。这个`Schedual`
使用固定的线程池，大小为CPU的核数。不适合将IO操作放在`computation`中，因为I/O的等待时间会浪费CPU。

* `AndroidScheduals.mainThread()`: 安卓主线程

有了这几个`Schedual`我们就可以自由切换我们的线程了。

* 切换Observable工作发生的线程: subscriptOn(Schedual)
* 切换Observer工作发生的线程: observerOn(Shcedual)

比如我们模拟从I/O线程取得一个bitmap。然后在主线程给ImageView设置上，可看Demo。

    void setImage() {
        Observable.create(new Observable.OnSubscribe<Drawable>() {
            @Override
            public void call(Subscriber<? super Drawable> subscriber) {
                Log.i("tonghu", "get Image on " + Thread.currentThread().getName() + " thread");
                //通过睡眠模拟耗时操作
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Drawable d = getResources().getDrawable(R.mipmap.ic_launcher);
                subscriber.onNext(d);
            }
        })
        //指定被观察者在I/O线程执行
        .subscribeOn(Schedulers.io())

        //指定观察者在主线程执行
        .observeOn(AndroidSchedulers.mainThread())

        //注册
        .subscribe(new Action1<Drawable>() {
            @Override
            public void call(Drawable drawable) {
                Log.i("tonghu", "set imageView on " + Thread.currentThread().getName() + " thread");
                iv.setImageDrawable(drawable);
            }
        });
    }

### 操作符
RxJava提供了许多操作符，那么什么是操作符呢？

操作符是改变事件分发的流程。我们来看其中的几个例子

#### Obervable.from
<img src="http://reactivex.io/documentation/operators/images/from.c.png">

使用from改写原来打印字符数组的例子

    final String[] toPrint = new String[]{"One", "Two", "Three"};
    Observable.from(toPrint)
    .subscribe(new Action1<String>() {
      @Override
      public void call(String s) {
        Log.i("tonghu", "printArray: " + s);
      }
    });

#### observer.map
<img src="http://reactivex.io/documentation/operators/images/map.png">

就是将一个类型转换另一个类型，比如我们被观察者分发图片资源id，而观察者需要一个Drawable类型的图片

    void setImageByResourceId() {
        Observable.create(new Observable.OnSubscribe<Integer>() {
            @Override
            public void call(Subscriber<? super Integer> subscriber) {
                Log.i("tonghu", "get resourceId on " + Thread.currentThread().getName() + " thread");
                subscriber.onNext(R.mipmap.ic_launcher);
            }
        })
        //转换类型
        .map(new Func1<Integer, Drawable>() {
            @Override
            public Drawable call(Integer integer) {
                //模拟图片获取是一个耗时操作，放在I/O线程执行
                Log.i("tonghu", "get Image on " + Thread.currentThread().getName() + " thread");
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Drawable d = getResources().getDrawable(R.mipmap.ic_launcher);
                return d;
            }
        })
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Action1<Drawable>() {
            @Override
            public void call(Drawable drawable) {
                Log.i("tonghu", "set imageView on " + Thread.currentThread().getName() + " thread");
                iv.setImageDrawable(drawable);
            }
        })
        ;
    }


#### observable.flatMap
<img src="http://reactivex.io/documentation/operators/images/flatMap.c.png">

这里的`map()`方法是单对单的转变，即一个id对应了一个drawable。原来的onNext()调用多少次，现在的onNext()就调用多少次。

如果要进行一对多的对应，则要用到的是`flatMap()`，偷点懒，就只给一个示例例子。

要打印每个学生的科目科目成绩，因为每个学生有多门课程，这里就需要进行一个一对多的转换。

`flatMap()`: 将T转换成一个Observable。实际onNext(T data)方法调用会转变成observable的OnNext()的方法调用。可用于结果一对多的转变

    Observer.from(students)
    .filterMap(new Func1<Student, Observable<Course>>() {
        publci Observable<Course> call(Student s) {
            return Obserbale.from(student.getCourses());
        } 
    }) 
    .subscrbe(subsciber);

#### observable.merge(observable1, observable2...)
<img src="http://reactivex.io/documentation/operators/images/merge.png">

#### observable.mergeDelayError(observable1, observable2...)
<img src="http://reactivex.io/documentation/operators/images/mergeDelayError.png">
延迟错误的发生

#### obsevable.sample()
<img src="http://reactivex.io/documentation/operators/images/sample.png">
没隔一段时间取样，去最近发生的一个

#### observable.first()
<img src="http://reactivex.io/documentation/operators/images/first.png">
取第一个

现在我们看一个综合的例子。

app启动时从网络和本地缓存去广告图，取图是一个耗时的操作，如果两秒内没有取到，则跳到主页面。如果取到了，则展示广告图，展示2秒后跳到主页面。用RxJava的写法如下：

    //从本地加载广告图,I/O线程
    Observable<Drawable> loadBitmapFromLocalObservable = Observable.create(new Observable.OnSubscribe<Drawable>() {
        @Override
        public void call(Subscriber<? super Drawable> subscriber) {

        }
    }).subscribeOn(Schedulers.io());

    //从网络加载广告图,I/O线程
    Observable<Drawable> cacheNetBitmapObservable = Observable.create(new Observable.OnSubscribe<Drawable>() {
        @Override
        public void call(Subscriber<? super Drawable> subscriber) {

        }

    }).subscribeOn(Schedulers.io());

    final ImageView image = null;
    Observable.mergeDelayError(
            loadBitmapFromLocalObservable.subscribeOn(Schedulers.io()),
            cacheNetBitmapObservable.subscribeOn(Schedulers.io()),
            //等三秒发送超时事件
            Observable.timer(3, TimeUnit.SECONDS).map(new Func1<Long, Drawable>() {
                @Override
                public Drawable call(Long aLong) {
                    return null;
                }

            })
    )
    .sample(2, TimeUnit.SECONDS, AndroidSchedulers.mainThread())  //每隔两秒扫描一次
    .first()                                            //只拿一次
    .flatMap(new Func1<Drawable, Observable<?>>() {

        @Override
        public Observable<?> call(Drawable drawable) {
            //没有拿到图
            if (drawable == null) {
                return Observable.empty();
            } else {
                //拿到图了
                image.setImageDrawable(drawable);
                return Observable.timer(2, TimeUnit.SECONDS);
            }
        }
    })
    .subscribe(new Action1<Object>() {
        @Override
        public void call(Object o) {
            //go next
        }
    });

我们可以看到，使用Rxjava的写法，逻辑很清晰。


#### observer.publish(), observer.connect()
<img src="http://reactivex.io/documentation/operators/images/publishConnect.c.png">
publish将一个普通的Observable改为一个可连接的Observable。普通的Observable一注册就开始分发事件，但是可连接的Observable只有在调用connect的时候才开始分发事件，这样你就能控制分发事件的时间点了。

比如我拿到user数据，我想在I/O线程写入数据库，在UI线程更新界面。这样怎么做呢。RxJava给我我们`publis()`的方法。可参见Demo。这也是操作符的一种。

注意代码中用到了项目使用的具体框架，在具体Demo中是可以运行的。

    //拿到user,并且模拟存储到数据库,并且更新界面
    ConnectableObservable<RegEntity> publish = Observable.create(new Observable.OnSubscribe<RegEntity>() {
        RegEntity rst = null;

        @Override
        public void call(final Subscriber<? super RegEntity> subscriber) {
            if (rst == null) {
                Map<String, String> params = new HashMap<String, String>();
                params.put("username", "foo");
                params.put("password", "bar");
                RequestManager.getRequest(MainActivity.this).startRequest(
                    "http://test.haibei.com/api/member/login",
                    params, new OnRequestResultListener() {
                      @Override
                      public void onError(int i, String s) {
                          Log.i("tonghu", "onError() " + s);
                          subscriber.onError(new Throwable());
                      }

                      @Override
                      public void onResult(JSONObject jsonObject) {
                          Log.i("tonghu", "onResult() ");
                          subscriber.onNext(new Gson().fromJson(jsonObject.toString(), RegEntity.class));
                      }

                      @Override
                      public void onPreHandle(IBusinessRequest iBusinessRequest) {

                      }
                    });
                Log.i("tonghu", "send getUser request");
            } else {
                subscriber.onNext(rst);
            }
        }
    }).publish();

    publish.observeOn(Schedulers.io())
    .subscribe(new Action1<RegEntity>() {
        @Override
        public void call(RegEntity regEntity) {
            try {
              Thread.sleep(5000);
            } catch (InterruptedException e) {
              e.printStackTrace();
            }
            Log.i("tonghu", "write to db success on " + Thread.currentThread().getName() + " thread");
        }
    });

    publish.observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Action1<RegEntity>() {
        @Override
        public void call(RegEntity regEntity) {
            Log.i("tonghu", "updateUI in " + Thread.currentThread().getName() + " thread!");
        }
    });

    publish.connect();

Rxjava的操作符非常多，我们只介绍这几样。

## Observable 操作符
Observable的操作符多且强大，这也不一一介绍了。大致可以分为以下几类。也可以在后面找到具体的说明。

### 创建性Creating Observables
* Observale.create()
* Observale.just()
* Observale.from()

### 转换型Transforming Observables
* observable.map()
* observable.flatMap()
* observable.buffer()

### 过滤型Filtering Observables
* observable.filter()
* observable.sample()
* observable.take()

### 组合型Combining Observables
* observable.join()
* observable.merge()
* observable.combineLaster()

### 错误处理型Error Handing Operators
* observable.onErrorResumeNext()
* observable.retry()

### Observable功能型Observable Utility Operators
* observable.subscribeOn()
* observable.observerOn()
* observable.delay()

### Observable条件型Conditional and Boolean Operators
* observable.amb()
* observable.contains()
* observable.skipUntil()

### Obsevable数学运算及聚合操作符Mathematical and Aggregate Operators
* observable.count()
* observable.reduce()
* obervable.concat()

### 其它
* observable.toList()
* observable.connect()
* observable.publish()

具体解释可参见<http://blog.csdn.net/job_hesc/article/details/46242117>

## RxJava流派Android库

Rxjava写法的Android工具库

* 网络请求：[Rretrofit](https://github.com/square/retrofit)

* UI widgets: [RxBindijg](https://github.com/JakeWharton/RxBinding)

提供了View操作的RxJava写法，比如使用`clickEvents(View view)`来替代`setOnClickListener()`。

下面这个例子来自Rxjava-Android-Samples中的BuffedDemoFragment。只要工作是每隔2秒统计一次点击点击了多少下按钮

    private Subscription _getBufferedSubscription() {
        return RxView.clickEvents(_tapBtn)
              .map(new Func1<ViewClickEvent, Integer>() {
                  @Override
                  public Integer call(ViewClickEvent onClickEvent) {
                      Timber.d("--------- GOT A TAP");
                      _log("GOT A TAP");
                      return 1;
                  }
              })
              .buffer(2, TimeUnit.SECONDS)
              .observeOn(AndroidSchedulers.mainThread())
              .subscribe(new Observer<List<Integer>>() {

                  @Override
                  public void onCompleted() {
                      // fyi: you'll never reach here
                      Timber.d("----- onCompleted");
                  }

                  @Override
                  public void onError(Throwable e) {
                      Timber.e(e, "--------- Woops on error!");
                      _log("Dang error! check your logs");
                  }

                  @Override
                  public void onNext(List<Integer> integers) {
                      Timber.d("--------- onNext");
                      if (integers.size() > 0) {
                          _log(String.format("%d taps", integers.size()));
                      } else {
                          Timber.d("--------- No taps received ");
                      }
                  }
              });
    }

buffer的作用是每隔一段时间打包一次Event

* RxBus：RxBus并不是一个库。而是使用RxJava来实现EventBus功能

RxBus的实现：


    // this is the middleman object
    public class RxBus {

        private final Subject<Object, Object> _bus = new SerializedSubject<>(PublishSubject.create());

        public void send(Object o) {
            bus.onNext(o);
        }

        public Observable<Object> toObserverable() {
            return _bus;
        }
    } 
    
使用方法：

发送Event to bus


    @OnClick(R.id.btn_demo_rxbus_tap)
    public void onTapButtonClicked() {

        _rxBus.send(new TapEvent());
    }
    

监听Event：

    // note that it is important to subscribe to the exact same _rxBus instance that was used to post the events
    _rxBus.toObserverable()
        .subscribe(new Action1<Object>() {
          @Override
          public void call(Object event) {

            if(event instanceof TapEvent) {
              _showTapText();

            }else if(event instanceof SomeOtherEvent) {
              _doSomethingElse();
            }
          }
        });

现在我们来看RxBus的实现。它的发送和注册都是代理的_bus的发送事件和注册。而_bus是`SerializedSubject`类型的

这个SerializedSubject又是什么呢？我们从RxJava的源码可以看到它是一个`Subject`。而`Subject`类的概念是一个既是观察者也是被观察者的类。它`extends Observable<R> implements Observer<T>`。

我们通过它发送事件和监听事件。它代理了一个`PublishSubject`。而`PublishSubject`也是一个`Subject`，这个`Subject`比较特殊，它可以通过`onNext()`方法来动态提交事件。通过源码我们大体知道，`PublishSubject`保存了每个注册上来的`observer`。调用`onNext()`的时候，遍历它的`observer`来分发事件，有点像`publish`操作符。

这里有一个人写的RxAndroid Demo集合<https://github.com/kaushikgopal/RxJava-Android-Samples>


参考资料：

> <http://reactivex.io>

> <http://reactivex.io/documentation/operators.html>

> <https://github.com/ReactiveX/RxJava/wiki/Connectable-Observable-Operators>
